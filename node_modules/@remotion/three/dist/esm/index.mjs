var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});

// src/ThreeCanvas.tsx
import { Canvas, useThree } from "@react-three/fiber";
import { useCallback, useEffect, useLayoutEffect as useLayoutEffect2, useState } from "react";
import {
  Internals,
  useCurrentFrame,
  useDelayRender as useDelayRender2,
  useRemotionEnvironment
} from "remotion";

// src/SuspenseLoader.tsx
import { Suspense, useLayoutEffect } from "react";
import { useDelayRender } from "remotion";
import { jsx } from "react/jsx-runtime";
var Unblocker = () => {
  const { delayRender, continueRender } = useDelayRender();
  if (typeof document !== "undefined") {
    useLayoutEffect(() => {
      const handle = delayRender(`Waiting for <Suspense /> of <ThreeCanvas /> to resolve`);
      return () => {
        continueRender(handle);
      };
    }, [continueRender, delayRender]);
  }
  return null;
};
var SuspenseLoader = ({ children }) => {
  return /* @__PURE__ */ jsx(Suspense, {
    fallback: /* @__PURE__ */ jsx(Unblocker, {}),
    children
  });
};

// src/validate.ts
import { NoReactInternals } from "remotion/no-react";
var validateDimension = NoReactInternals.validateDimension;

// src/ThreeCanvas.tsx
import { jsx as jsx2, jsxs } from "react/jsx-runtime";
var Scale = ({
  width,
  height
}) => {
  const { set, setSize: threeSetSize } = useThree();
  const [setSize] = useState(() => threeSetSize);
  useLayoutEffect2(() => {
    setSize(width, height);
    set({ setSize: () => null });
    return () => set({ setSize });
  }, [setSize, width, height, set]);
  return null;
};
var FiberFrameInvalidator = () => {
  const { invalidate } = useThree();
  const frame = useCurrentFrame();
  useEffect(() => {
    invalidate();
  }, [frame, invalidate]);
  return null;
};
var ThreeCanvas = (props) => {
  const { isRendering } = useRemotionEnvironment();
  const shouldUseFrameloopDemand = isRendering;
  const { children, width, height, style, onCreated, ...rest } = props;
  const { delayRender, continueRender } = useDelayRender2();
  const [waitForCreated] = useState(() => delayRender("Waiting for <ThreeCanvas/> to be created"));
  validateDimension(width, "width", "of the <ThreeCanvas /> component");
  validateDimension(height, "height", "of the <ThreeCanvas /> component");
  const contexts = Internals.useRemotionContexts();
  const actualStyle = {
    width: props.width,
    height: props.height,
    ...style ?? {}
  };
  const remotion_onCreated = useCallback((state) => {
    continueRender(waitForCreated);
    onCreated?.(state);
  }, [onCreated, waitForCreated, continueRender]);
  return /* @__PURE__ */ jsx2(SuspenseLoader, {
    children: /* @__PURE__ */ jsxs(Canvas, {
      style: actualStyle,
      ...rest,
      frameloop: shouldUseFrameloopDemand ? "demand" : "always",
      onCreated: remotion_onCreated,
      children: [
        /* @__PURE__ */ jsx2(Scale, {
          width,
          height
        }),
        /* @__PURE__ */ jsxs(Internals.RemotionContextProvider, {
          contexts,
          children: [
            shouldUseFrameloopDemand && /* @__PURE__ */ jsx2(FiberFrameInvalidator, {}),
            children
          ]
        })
      ]
    })
  });
};
// src/use-offthread-video-texture.ts
import { useCallback as useCallback2, useLayoutEffect as useLayoutEffect3, useMemo, useState as useState2 } from "react";
import {
  Internals as Internals2,
  useCurrentFrame as useCurrentFrame2,
  useDelayRender as useDelayRender3,
  useRemotionEnvironment as useRemotionEnvironment2,
  useVideoConfig
} from "remotion";
import { NoReactInternals as NoReactInternals2 } from "remotion/no-react";
var useInnerVideoTexture = ({
  playbackRate,
  src,
  transparent,
  toneMapped,
  delayRenderRetries,
  delayRenderTimeoutInMilliseconds
}) => {
  const frame = useCurrentFrame2();
  const { fps } = useVideoConfig();
  const mediaStartsAt = Internals2.useMediaStartsAt();
  const currentTime = useMemo(() => {
    return NoReactInternals2.getExpectedMediaFrameUncorrected({
      frame,
      playbackRate,
      startFrom: -mediaStartsAt
    }) / fps;
  }, [frame, playbackRate, mediaStartsAt, fps]);
  const offthreadVideoFrameSrc = useMemo(() => {
    return NoReactInternals2.getOffthreadVideoSource({
      currentTime,
      src,
      transparent,
      toneMapped
    });
  }, [toneMapped, currentTime, src, transparent]);
  const [textLoaderPromise] = useState2(() => import("three/src/loaders/TextureLoader.js"));
  const [imageTexture, setImageTexture] = useState2(null);
  const { delayRender, continueRender, cancelRender } = useDelayRender3();
  const fetchTexture = useCallback2(() => {
    const imageTextureHandle = delayRender("fetch offthread video frame", {
      retries: delayRenderRetries ?? undefined,
      timeoutInMilliseconds: delayRenderTimeoutInMilliseconds ?? undefined
    });
    let textureLoaded = null;
    let cleanedUp = false;
    textLoaderPromise.then((loader) => {
      new loader.TextureLoader().loadAsync(offthreadVideoFrameSrc).then((texture) => {
        textureLoaded = texture;
        if (cleanedUp) {
          return;
        }
        setImageTexture(texture);
        continueRender(imageTextureHandle);
      }).catch((err) => {
        cancelRender(err);
      });
    });
    return () => {
      cleanedUp = true;
      textureLoaded?.dispose();
      continueRender(imageTextureHandle);
    };
  }, [
    offthreadVideoFrameSrc,
    textLoaderPromise,
    delayRenderRetries,
    delayRenderTimeoutInMilliseconds,
    continueRender,
    delayRender,
    cancelRender
  ]);
  useLayoutEffect3(() => {
    const cleanup = fetchTexture();
    return () => {
      cleanup();
    };
  }, [offthreadVideoFrameSrc, fetchTexture]);
  return imageTexture;
};
function useOffthreadVideoTexture({
  src,
  playbackRate = 1,
  transparent = false,
  toneMapped = true,
  delayRenderRetries,
  delayRenderTimeoutInMilliseconds
}) {
  if (!src) {
    throw new Error("src must be provided to useOffthreadVideoTexture");
  }
  const env = useRemotionEnvironment2();
  const { isRendering, isClientSideRendering } = env;
  if (isClientSideRendering) {
    throw new Error("useOffthreadVideoTexture() cannot be used in client-side rendering.");
  }
  if (!isRendering) {
    throw new Error("useOffthreadVideoTexture() can only be used during rendering. Use useRemotionEnvironment().isRendering to render it conditionally.");
  }
  return useInnerVideoTexture({
    playbackRate,
    src,
    transparent,
    toneMapped,
    delayRenderRetries,
    delayRenderTimeoutInMilliseconds
  });
}

// src/use-video-texture.ts
import React3, { useCallback as useCallback3, useEffect as useEffect2, useState as useState3 } from "react";
import {
  useCurrentFrame as useCurrentFrame3,
  useDelayRender as useDelayRender4,
  useRemotionEnvironment as useRemotionEnvironment3
} from "remotion";
var warned = false;
var warnAboutRequestVideoFrameCallback = () => {
  if (warned) {
    return false;
  }
  warned = true;
  console.warn("Browser does not support requestVideoFrameCallback. Cannot display video.");
};
var useVideoTexture = (videoRef) => {
  const { delayRender, continueRender, cancelRender } = useDelayRender4();
  const [loaded] = useState3(() => {
    if (typeof document === "undefined") {
      return 0;
    }
    return delayRender(`Waiting for texture in useVideoTexture() to be loaded`);
  });
  const environment = useRemotionEnvironment3();
  const { isClientSideRendering } = environment;
  if (isClientSideRendering) {
    throw new Error("useVideoTexture() cannot be used in client side rendering.");
  }
  const [videoTexture, setVideoTexture] = useState3(null);
  const [vidText] = useState3(() => import("three/src/textures/VideoTexture.js"));
  const frame = useCurrentFrame3();
  const onReady = useCallback3(() => {
    vidText.then(({ VideoTexture }) => {
      if (!videoRef.current) {
        throw new Error("Video not ready");
      }
      const vt = new VideoTexture(videoRef.current);
      videoRef.current.width = videoRef.current.videoWidth;
      videoRef.current.height = videoRef.current.videoHeight;
      setVideoTexture(vt);
      continueRender(loaded);
    }).catch((err) => {
      cancelRender(err);
    });
  }, [loaded, vidText, videoRef, continueRender, cancelRender]);
  React3.useLayoutEffect(() => {
    if (!videoRef.current) {
      return;
    }
    if (videoRef.current.readyState >= 2) {
      onReady();
      return;
    }
    videoRef.current.addEventListener("loadeddata", () => {
      onReady();
    }, { once: true });
  }, [loaded, onReady, videoRef]);
  React3.useEffect(() => {
    const { current } = videoRef;
    if (!current) {
      return;
    }
    if (!current.requestVideoFrameCallback) {
      warnAboutRequestVideoFrameCallback();
      return;
    }
    const ready = () => {};
    current.requestVideoFrameCallback(ready);
  }, [frame, loaded, videoRef]);
  useEffect2(() => {
    return () => {
      continueRender(loaded);
    };
  }, [loaded, continueRender]);
  if (typeof HTMLVideoElement === "undefined" || !HTMLVideoElement.prototype.requestVideoFrameCallback) {
    continueRender(loaded);
    return null;
  }
  return videoTexture;
};

// src/index.ts
var useOffthreadVideoTexture2 = useOffthreadVideoTexture;
var useVideoTexture2 = useVideoTexture;
export {
  useVideoTexture2 as useVideoTexture,
  useOffthreadVideoTexture2 as useOffthreadVideoTexture,
  ThreeCanvas
};
