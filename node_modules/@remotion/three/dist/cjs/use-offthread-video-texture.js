"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.useInnerVideoTexture = void 0;
exports.useOffthreadVideoTexture = useOffthreadVideoTexture;
const react_1 = require("react");
const remotion_1 = require("remotion");
const no_react_1 = require("remotion/no-react");
const useInnerVideoTexture = ({ playbackRate, src, transparent, toneMapped, delayRenderRetries, delayRenderTimeoutInMilliseconds, }) => {
    const frame = (0, remotion_1.useCurrentFrame)();
    const { fps } = (0, remotion_1.useVideoConfig)();
    const mediaStartsAt = remotion_1.Internals.useMediaStartsAt();
    const currentTime = (0, react_1.useMemo)(() => {
        return (no_react_1.NoReactInternals.getExpectedMediaFrameUncorrected({
            frame,
            playbackRate,
            startFrom: -mediaStartsAt,
        }) / fps);
    }, [frame, playbackRate, mediaStartsAt, fps]);
    const offthreadVideoFrameSrc = (0, react_1.useMemo)(() => {
        return no_react_1.NoReactInternals.getOffthreadVideoSource({
            currentTime,
            src,
            transparent,
            toneMapped,
        });
    }, [toneMapped, currentTime, src, transparent]);
    const [textLoaderPromise] = (0, react_1.useState)(() => Promise.resolve().then(() => __importStar(require('three/src/loaders/TextureLoader.js'))));
    const [imageTexture, setImageTexture] = (0, react_1.useState)(null);
    const { delayRender, continueRender, cancelRender } = (0, remotion_1.useDelayRender)();
    const fetchTexture = (0, react_1.useCallback)(() => {
        const imageTextureHandle = delayRender('fetch offthread video frame', {
            retries: delayRenderRetries !== null && delayRenderRetries !== void 0 ? delayRenderRetries : undefined,
            timeoutInMilliseconds: delayRenderTimeoutInMilliseconds !== null && delayRenderTimeoutInMilliseconds !== void 0 ? delayRenderTimeoutInMilliseconds : undefined,
        });
        let textureLoaded = null;
        let cleanedUp = false;
        textLoaderPromise.then((loader) => {
            new loader.TextureLoader()
                .loadAsync(offthreadVideoFrameSrc)
                .then((texture) => {
                textureLoaded = texture;
                if (cleanedUp) {
                    return;
                }
                setImageTexture(texture);
                continueRender(imageTextureHandle);
            })
                .catch((err) => {
                cancelRender(err);
            });
        });
        return () => {
            cleanedUp = true;
            textureLoaded === null || textureLoaded === void 0 ? void 0 : textureLoaded.dispose();
            continueRender(imageTextureHandle);
        };
    }, [
        offthreadVideoFrameSrc,
        textLoaderPromise,
        delayRenderRetries,
        delayRenderTimeoutInMilliseconds,
        continueRender,
        delayRender,
        cancelRender,
    ]);
    (0, react_1.useLayoutEffect)(() => {
        const cleanup = fetchTexture();
        return () => {
            cleanup();
        };
    }, [offthreadVideoFrameSrc, fetchTexture]);
    return imageTexture;
};
exports.useInnerVideoTexture = useInnerVideoTexture;
/*
 * @description Allows you to use a video in React Three Fiber that is synchronized with Remotion's `useCurrentFrame()` using the `<OffthreadVideo>`.
 * @see [Documentation](https://www.remotion.dev/docs/use-offthread-video-texture)
 */
function useOffthreadVideoTexture({ src, playbackRate = 1, transparent = false, toneMapped = true, delayRenderRetries, delayRenderTimeoutInMilliseconds, }) {
    if (!src) {
        throw new Error('src must be provided to useOffthreadVideoTexture');
    }
    const env = (0, remotion_1.useRemotionEnvironment)();
    const { isRendering, isClientSideRendering } = env;
    if (isClientSideRendering) {
        throw new Error('useOffthreadVideoTexture() cannot be used in client-side rendering.');
    }
    if (!isRendering) {
        throw new Error('useOffthreadVideoTexture() can only be used during rendering. Use useRemotionEnvironment().isRendering to render it conditionally.');
    }
    return (0, exports.useInnerVideoTexture)({
        playbackRate,
        src,
        transparent,
        toneMapped,
        delayRenderRetries,
        delayRenderTimeoutInMilliseconds,
    });
}
