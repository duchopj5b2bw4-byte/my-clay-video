"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ThreeCanvas = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const fiber_1 = require("@react-three/fiber");
const react_1 = require("react");
const remotion_1 = require("remotion");
const SuspenseLoader_1 = require("./SuspenseLoader");
const validate_1 = require("./validate");
const Scale = ({ width, height, }) => {
    const { set, setSize: threeSetSize } = (0, fiber_1.useThree)();
    const [setSize] = (0, react_1.useState)(() => threeSetSize);
    (0, react_1.useLayoutEffect)(() => {
        setSize(width, height);
        set({ setSize: () => null });
        return () => set({ setSize });
    }, [setSize, width, height, set]);
    return null;
};
const FiberFrameInvalidator = () => {
    const { invalidate } = (0, fiber_1.useThree)();
    const frame = (0, remotion_1.useCurrentFrame)();
    (0, react_1.useEffect)(() => {
        invalidate();
    }, [frame, invalidate]);
    return null;
};
/*
 * @description A wrapper for React Three Fiber's <Canvas /> which synchronizes with Remotion's useCurrentFrame().
 * @see [Documentation](https://www.remotion.dev/docs/three-canvas)
 */
const ThreeCanvas = (props) => {
    const { isRendering } = (0, remotion_1.useRemotionEnvironment)();
    // https://r3f.docs.pmnd.rs/advanced/scaling-performance#on-demand-rendering
    const shouldUseFrameloopDemand = isRendering;
    const { children, width, height, style, onCreated, ...rest } = props;
    const { delayRender, continueRender } = (0, remotion_1.useDelayRender)();
    const [waitForCreated] = (0, react_1.useState)(() => delayRender('Waiting for <ThreeCanvas/> to be created'));
    (0, validate_1.validateDimension)(width, 'width', 'of the <ThreeCanvas /> component');
    (0, validate_1.validateDimension)(height, 'height', 'of the <ThreeCanvas /> component');
    const contexts = remotion_1.Internals.useRemotionContexts();
    const actualStyle = {
        width: props.width,
        height: props.height,
        ...(style !== null && style !== void 0 ? style : {}),
    };
    const remotion_onCreated = (0, react_1.useCallback)((state) => {
        continueRender(waitForCreated);
        onCreated === null || onCreated === void 0 ? void 0 : onCreated(state);
    }, [onCreated, waitForCreated, continueRender]);
    return ((0, jsx_runtime_1.jsx)(SuspenseLoader_1.SuspenseLoader, { children: (0, jsx_runtime_1.jsxs)(fiber_1.Canvas, { style: actualStyle, ...rest, frameloop: shouldUseFrameloopDemand ? 'demand' : 'always', onCreated: remotion_onCreated, children: [(0, jsx_runtime_1.jsx)(Scale, { width: width, height: height }), (0, jsx_runtime_1.jsxs)(remotion_1.Internals.RemotionContextProvider, { contexts: contexts, children: [shouldUseFrameloopDemand && (0, jsx_runtime_1.jsx)(FiberFrameInvalidator, {}), children] })] }) }));
};
exports.ThreeCanvas = ThreeCanvas;
